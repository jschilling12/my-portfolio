---
layout: post
title: "Windows Process Tracking & Logic"
date: 2025-12-06
category: focus-buddy
---

# Project Update: Windows Process Querying

I started this session with two main questions: **where will I store the data** and **how can I capture a window?** Once those variables were set, it became a matter of logic.

## Windows Process Query 
Starting with a simple query on Windows process handling, it turns out processes are directly connected to **win32 wrappers**. This makes capture relatively easy; now itâ€™s just about timing.

I utilized these resources to assist with process capture:
* [Track Windows App Usage (Dev.to)](https://dev.to/tkkhhaarree/track-windows-app-usage-time-using-python-h9h)
* [Obtain Active Window (Stack Overflow)](https://stackoverflow.com/questions/10266281/obtain-active-window-using-python)

## Time Module and Loop
I moved on to learning about the `time` module to ensure a consistent loop. I'm using a **1-second timer** to capture start and end times. 

Initially, the documentation was a bit difficult to parse, but it clicked once I figured out how `time.sleep()` manages the loop frequency in conjunction with start and end timestamps.
* [Python Time Module Documentation](https://docs.python.org/3/library/time.html)

## Logic for Process Monitoring
The logic follows a simple "snapshot" approach: 
1. Is the current process still matching the "new process" snapshot? 
2. **Yes:** No intervention needed (system checks every 1 second).
3. **No:** The timer calculates the duration of the old process, and the new process replaces it as the "current" one.

## Permissions and Access Denial
I encountered some confusion around permissions and access denial. I found documentation and implemented `try/except` blocks to handle these edge cases. With the guidance of AI (set to study and learn mode), I refactored the code to avoid crashes due to permission errors.

```python
from pydoc import resolve
import sqlite3
import os
from pathlib import Path
from typing import Optional

def connect_db(db_path: Optional[str] = None):

    if db_path is None:
        db_path = os.environ.get(
        "DATABASE_NAME",
            str((Path(__file__).parent.parent / "time_tracking.db").resolve()),
        )
    return sqlite3.connect(db_path)

def init_db():
    with connect_db()as conn:
        cursor = conn.cursor()
        
        #Time Tracking Table
        cursor.execute('''
                       CREATE TABLE IF NOT EXISTS time_tracking (
                       id INTEGER PRIMARY KEY,
                       app_name TEXT,
                       date INTEGER, 
                       time_tracked INTEGER DEFAULT 0,
                       UNIQUE(app_name, date)
                       )
                       ''')
        
```

* [Process Security and Access Rights](https://learn.microsoft.com/en-us/windows/win32/procthread/process-security-and-access-rights)
* [Using Windows Headers](https://learn.microsoft.com/en-us/windows/win32/winprog/using-the-windows-headers)
* [SeDebugPrivilege Background](https://jongampark.wordpress.com/2008/09/30/opening-a-process-with-se_debug_name-privilege/)

## SQL Database and Future Plans
I finished the session by building a skeleton for a **SQL database** to store the time-tracking data, utilizing some of my previous code. I'm planning to tackle the "Focus Buddy" features last, as the time-tracking algorithm was the more complex hurdle to clear first.